/**
 * White Cap Provider
 * 
 * Implementation of the provider interface for White Cap supplier.
 * This is completely independent from the Home Depot implementation.
 */

const BaseProvider = require('./provider-interface');
const DatabaseService = require('../services/database');
const { DB_CONFIG } = require('../config/db');
const logger = require('../config/logging')();
const axios = require('axios');
const retry = require('async-retry');

/**
 * White Cap Provider implementation
 */
class WhiteCapProvider extends BaseProvider {
  /**
   * @param {Object} config - Provider configuration
   */
  constructor(config = {}) {
    super(config);
    this.apiBaseUrl = config.apiBaseUrl || process.env.WHITECAP_API_BASE_URL || 'http://167.114.223.83:3005/wc/api';
    this.dbService = new DatabaseService(DB_CONFIG);
    this.dbInitialized = false;
    this.stockLevel = parseInt(process.env.WHITECAP_STOCK_LEVEL || process.env.STOCK_LEVEL || '5', 10);
    this.handlingTimeOmd = parseInt(process.env.WHITECAP_HANDLING_TIME_OMD || process.env.LEAD_TIME_OMD || '2', 10);
    this.whiteCapHandlingTime = parseInt(process.env.WHITECAP_HANDLING_TIME || '2', 10);
    this.requestsPerSecond = parseInt(process.env.WHITECAP_REQUESTS_PER_SECOND || process.env.REQUESTS_PER_SECOND || '7', 10);
    this.updateFlagValue = parseInt(process.env.WHITECAP_UPDATE_FLAG_VALUE || '3', 10);
    
    // Log configuration
    logger.info(`White Cap Provider initialized with:`);
    logger.info(`API Base URL: ${this.apiBaseUrl}`);
    logger.info(`Stock Level: ${this.stockLevel}`);
    logger.info(`Handling Time OMD: ${this.handlingTimeOmd}`);
    logger.info(`Handling Time White Cap: ${this.whiteCapHandlingTime}`);
    logger.info(`Requests Per Second: ${this.requestsPerSecond}`);
    logger.info(`Update Flag Value: ${this.updateFlagValue}`);
  }

  /**
   * Initialize database connection
   * @returns {Promise<void>}
   */
  async init() {
    if (!this.dbInitialized) {
      await this.dbService.init();
      this.dbInitialized = true;
      logger.info(`Database connection initialized for ${this.getName()} provider`);
    }
  }

  /**
   * Close database connection and other resources
   * @returns {Promise<void>}
   */
  async close() {
    logger.info(`Closing ${this.getName()} provider resources`);
    if (this.dbInitialized) {
      await this.dbService.close();
      this.dbInitialized = false;
      logger.info(`${this.getName()} database connection closed`);
    }
    logger.info(`${this.getName()} provider resources closed successfully`);
  }

  /**
   * Get provider identifier
   * @returns {string} Provider ID
   */
  getId() {
    return 'whitecap';
  }

  /**
   * Get provider name
   * @returns {string} Provider name
   */
  getName() {
    return 'White Cap';
  }

  /**
   * Get provider API service
   * @returns {Object} API service instance
   */
  getApiService() {
    return {
      fetchProductDataWithRetry: async (sku) => {
        return await this._fetchProductData(sku);
      }
    };
  }

  /**
   * Fetch product data from White Cap API
   * @param {string} sku - Product SKU
   * @returns {Promise<Object>} Product data
   * @private
   */
  async _fetchProductData(sku) {
    try {
      const url = `${this.apiBaseUrl}/${sku}`;
      logger.info(`Fetching White Cap product data: ${url}`);
      
      const response = await retry(
        async () => {
          const result = await axios.get(url, {
            headers: {
              'Accept': 'application/json',
              'User-Agent': 'FeedControl/1.0'
            },
            timeout: 30000
          });
          
          if (result.status !== 200) {
            throw new Error(`API returned status ${result.status}`);
          }
          
          return result;
        },
        {
          retries: 3,
          minTimeout: 1000,
          maxTimeout: 5000,
          onRetry: (error) => {
            logger.warn(`Retry fetching White Cap data for SKU ${sku}: ${error.message}`);
          }
        }
      );
      
      if (!response.data) {
        throw new Error('Empty response data');
      }
      
      // Transform API response to our internal format
      return this._transformProductData(response.data, sku);
      
    } catch (error) {
      logger.error(`Error fetching White Cap product data for SKU ${sku}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Transform White Cap API data to our internal format
   * @param {Object} apiData - API response data
   * @param {string} sku - Product SKU
   * @returns {Object} Transformed product data
   * @private
   */
  _transformProductData(apiData, sku) {
    // Calculate quantity based on stock and availability
    let quantity = 0;
    if (apiData.available && apiData.stock > 0) {
      quantity = apiData.stock;
      
      // Apply stock level threshold if configured
      if (this.stockLevel > 0 && quantity > this.stockLevel) {
        quantity = this.stockLevel;
      }
    }
    
    // Usar tempos de manuseio específicos para White Cap e OMD
    // O handling_time_amz (tempo total) será calculado no momento da atualização do banco de dados
    const whiteCapHandlingTime = this.whiteCapHandlingTime;
    
    // Return transformed data
    return {
      sku: sku,
      price: apiData.price || 0,
      quantity: quantity,
      whiteCapHandlingTime: whiteCapHandlingTime, // Valor específico da White Cap
      omdHandlingTime: this.handlingTimeOmd,      // Valor específico da OMD
      available: apiData.available || false,
      discontinued: apiData.discontinued || false,
      title: apiData.title || '',
      brand: apiData.brand || '',
      upc: apiData.upc || '',
      mfn: apiData.mfn || '',
      url: apiData.url || '',
      rawData: apiData // Store raw data for reference
    };
  }

  /**
   * Initialize sync
   * @returns {Promise<boolean>} Success flag
   */
  async initSync() {
    try {
      await this.init();
      // ... existing code ...
      return true;
    } catch (error) {
      logger.error(`Error initializing sync for ${this.getName()}: ${error.message}`);
      await this.close();
      return false;
    }
  }

  /**
   * Execute Phase 1 of synchronization (get product data from API)
   * @returns {Promise<number>} Number of products updated
   */
  async executePhase1() {
    try {
      await this.init();
      // ... existing code ...
    } catch (error) {
      logger.error(`Error executing Phase 1 for ${this.getName()}: ${error.message}`, { error });
      throw error;
    } finally {
      await this.close();
    }
  }

  /**
   * Execute Phase 2 of synchronization (submit feed to Amazon)
   * @returns {Promise<Object>} Result of feed submission
   */
  async executePhase2() {
    try {
      await this.init();
      // ... existing code ...
    } catch (error) {
      logger.error(`Error executing Phase 2 for ${this.getName()}: ${error.message}`, { error });
      throw error;
    } finally {
      await this.close();
    }
  }

  /**
   * Reset updated products
   * @returns {Promise<Object>} Result of reset operation
   */
  async resetUpdatedProducts() {
    await this.init();
    
    try {
      // ... existing code ...
    } catch (error) {
      logger.error(`Error resetting updated products for ${this.getName()}: ${error.message}`, { error });
      throw error;
    } finally {
      await this.close();
    }
  }

  /**
   * Create inventory feed for Amazon
   * @param {Array<Object>} products - Products to include in feed
   * @returns {Object} Amazon inventory feed
   * @private
   */
  _createInventoryFeed(products) {
    // Create feed in Amazon SP-API format
    const feed = {
      header: {
        sellerId: process.env.AMAZON_SELLER_ID || "SELLER_ID_PLACEHOLDER",
        version: "2.0",
        issueLocale: "en_US"
      },
      messages: []
    };
    
    // Add each product to feed
    products.forEach((product, index) => {
      feed.messages.push({
        messageId: index + 1,
        sku: product.sku2,
        operationType: "PARTIAL_UPDATE",
        productType: "PRODUCT",
        attributes: {
          fulfillment_availability: [
            {
              fulfillment_channel_code: "DEFAULT",
              quantity: product.quantity,
              lead_time_to_ship_max_days: product.handling_time_amz
            }
          ]
        }
      });
    });
    
    return feed;
  }

  /**
   * Get SQL queries for extracting updated products for Phase 2
   * @returns {Object} SQL queries
   */
  getPhase2Queries() {
    return {
      extractUpdatedData: `
        SELECT 
          sku2, handling_time_amz, quantity 
        FROM produtos 
        WHERE atualizado = ${this.updateFlagValue} AND source = 'White Cap'
      `,
      resetUpdatedProducts: `
        UPDATE produtos
        SET atualizado = 0
        WHERE atualizado = ${this.updateFlagValue} AND source = 'White Cap'
      `
    };
  }
}

module.exports = WhiteCapProvider; 